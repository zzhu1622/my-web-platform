const pool = require('../config/database');
const bcrypt = require('bcrypt');

// Login function
exports.login = async (req, res) => {
    try {
        // Get email/uid and password from request body
        const { identifier, password } = req.body;

        // Validate input
        if (!identifier || !password) {
            return res.status(400).json({
                success: false,
                message: 'Please provide email/UID and password'
            });
        }

        // Try to get database connection
        let connection;
        try {
            connection = await pool.getConnection();
        } catch (dbError) {
            return res.status(503).json({
                success: false,
                message: 'Unable to connect to the database'
            });
        }

        try {
            // Query to find user by email OR UID
            const query = `
        SELECT UID, name, email, password 
        FROM User 
        WHERE email = ? OR UID = ?
      `;

            const [rows] = await connection.execute(query, [identifier, identifier]);

            // Check if user exists
            if (rows.length === 0) {
                connection.release();
                return res.status(401).json({
                    success: false,
                    message: 'Incorrect input of UID, email address or password'
                });
            }

            // Get user data
            const user = rows[0];

            // Compare passwords
            const passwordMatch = await bcrypt.compare(password, user.password);

            if (!passwordMatch) {
                connection.release();
                return res.status(401).json({
                    success: false,
                    message: 'Incorrect input of UID, email address or password'
                });
            }

            // Login successful - Create session record in database
            try {
                // Extract client IP address from request
                // Handles cases where application is behind a proxy/load balancer
                // Priority: x-forwarded-for header (set by proxies) -> connection IP -> socket IP -> 'Unknown'
                const clientIP = req.headers['x-forwarded-for'] ||
                    req.connection.remoteAddress ||
                    req.socket.remoteAddress ||
                    'Unknown';

                // Extract user agent from request
                // Contains browser, OS, and device information
                // Example: "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36..."
                const userAgent = req.headers['user-agent'] || 'Unknown';

                // SQL query to insert session record into UserSession table
                // SessionID is auto-generated by database (AUTO_INCREMENT)
                // login_time is set to database NOW() for accuracy and consistency
                // is_online defaults to 1 (TRUE) for new sessions
                const sessionQuery = `
                INSERT INTO UserSession (UID, login_time, ip_address, user_agent, is_online)
                VALUES (?, NOW(), ?, ?, 1)
              `;

                // Execute the insert query with parameters
                // This creates the session record in the database
                const [sessionResult] = await connection.execute(sessionQuery, [
                    user.UID,      // User ID of person logging in
                    clientIP,      // Client's IP address
                    userAgent      // Client's browser/device information
                ]);

                // Extract the SessionID from the insert result
                // This is the auto-generated ID that uniquely identifies this session
                // Will be stored in frontend localStorage for logout tracking
                const sessionID = sessionResult.insertId;

                // Release database connection back to pool
                connection.release();

                // Login successful with session created
                // Return sessionID to frontend along with user data
                return res.status(200).json({
                    success: true,
                    message: 'Login successful',
                    sessionID: sessionID,  // Return SessionID to frontend for tracking
                    user: {
                        UID: user.UID,
                        name: user.name,
                        email: user.email
                    }
                });

            } catch (sessionError) {
                // Session creation failed but login was successful
                connection.release();
                console.error('Session creation error:', sessionError);

                // Still return login success but without sessionID
                // This allows login to work even if session tracking fails
                // Session tracking is important but not critical for core functionality
                return res.status(200).json({
                    success: true,
                    message: 'Login successful',
                    sessionID: null,  // No session ID available
                    user: {
                        UID: user.UID,
                        name: user.name,
                        email: user.email
                    },
                    warning: 'Session tracking unavailable'
                });
            }

        } catch (queryError) {
            connection.release();
            console.error('Query error:', queryError);
            return res.status(503).json({
                success: false,
                message: 'Unable to connect to the database'
            });
        }

    } catch (error) {
        console.error('Login error:', error);
        return res.status(500).json({
            success: false,
            message: 'Server error'
        });
    }
};